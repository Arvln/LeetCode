# 743.Network-Delay-Time

求所有節點都能收到訊號的最短時間，等於是要算每個節點收到訊號所需最短時間中取最大值。在加權有向圖中求最短路徑，很容易可以想到Dijkstra算法。在無權圖中，每條路徑默認權重為1，因此只需要普通隊列就能實現BFS算法。在加權圖中，每條路徑權重不等，BFS算法搭配堆可以達到貪心的效果，堆的自動排序功能讓元素在首次彈出時，處在最優的狀態。此外，套用dp的思維也可以求圖中最短路徑，為需要N^3複雜度的Floyd算法，算法本質上相當暴力，當圖的規模偏小時較適合使用，優點是對權重沒有正數的限制。這題節點最多100個，算法的複雜度約是10^6，肯定不會TLE。

```
i X X X X X k X X X j

dp[i][j]: the minimum time it takes from i to j.

dp[i][j]=min(dp[i][j], dp[i][k]+dp[k][j]);
```

算法思維很簡單，找到任意一個中間點k，則i到k的最短距離加上k到j的最短距離都有機會更新i到j的最短距離。題目提供的有向圖就是dp的初始條件，當然，自己到自己的最短距離為0也是初始條件。
