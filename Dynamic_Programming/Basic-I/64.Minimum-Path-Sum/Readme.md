# 64.Minimum-Path-Sum

跟 #62 思路很相似，從左上到右下會產生大量重複路徑，適合用dp思路切入。

- 思考在位置{i, j}如何做選擇？

```
{i, j-1} -> {i, j}
{i-1, j} 
```

到達上方及左邊格子的最小和取小再加上當前格子的數字就會是從左上格到當前格的最小和。

- 思考需要哪些狀態？

需要代表位置的i, j。

- 明確dp數組的含義。

```
dp[i][j]: find a path from {0, 0} to {i, j}, which minimizes the sum of all numbers along its path.
```

- 推導狀態轉移方程。

```
dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j];
```

- 設定邊界條件及dp初始值。

到達最左上格子不包含該格子數字的和設為0，要求最小值dp數組初始值直接設最大值。

```
dp[0][0]=0;
```

- 得出結論。

到達{m-1, n-1}的最小和為dp[m-1][n-1]。
