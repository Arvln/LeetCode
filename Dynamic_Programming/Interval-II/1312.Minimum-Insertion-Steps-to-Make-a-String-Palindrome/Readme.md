# 1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome

分為正反兩種思路。正面來看直接求區間內新增多少字符可讓字串變回文。回文就是反轉後序列跟原始序列相同，因此將字串反轉後，跟原始字串求最長公共子序列長度，將總長度減去最長公共子序列長度可反推出最少要插入的字符數。

### 區間dp

- 可以做哪些選擇？

```
[i X X X X X X X j]
```

當s[i]跟s[j]相同，s[i:j]最少需要插入字符數跟s[i+1:j-1]相同。當s[i]不等於s[j]，s[i:j]最少需要插入字符數為s[i:j-1]最少需要插入字符數加上插入s[i]的操作跟s[i+1:j]最少需要插入字符數加上插入s[j]的操作再取小。

- 思考需要哪些狀態？

標示區間範圍的最左端i及最右端j。

- 定義dp數組含義。

```
dp[i][j]: the minimum number of steps to make s[i:j] palindrome.
```

- 推導狀態轉移方程。

```
if (s[i]==s[j]) dp[i][j]=dp[i+1][j-1];
else dp[i][j]=min(dp[i][j-1], dp[i+1][j])+1;
```

- 設定邊界條件及dp初始值。

當i大於j時不是可能區間，遍歷字串長度從3開始，確保dp值不會越界。字串長度小於3當作邊界條件額外設定。狀態會從小區間往大區間轉移不需設置dp數組初始值。

```
for (int i=0; i<n; i++)
  dp[i][i]=0;
for (int i=0; i+1<n; i++)
  dp[i][i+1]=s[i]!=s[j];
```

- 得出結論。

要讓s[0:n-1]變為回文串最少需要插入的字符數為dp[0][n-1]。

### LCS

將字串跟反轉字串按 #1143 的思路求出最長公共子序列長度後，總長度減去最長公共子序列長度就是最少需要插入的字符數。
