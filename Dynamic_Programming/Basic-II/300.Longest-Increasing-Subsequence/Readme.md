# 300.Longest-Increasing-Subsequence

求LIS通常有兩種思路，一種是N^2的dp解法、另一種是NlogN的二分法。

### dp

- 思考對於第i個元素可以做哪些選擇？

```
X X X j X X X i
```

當nums[i]>nums[j]時，以nums[j]結尾的最長遞增子序列長度再加上nums[i]就有機會更新nums[i]結尾的最長遞增子序列長度。

- 思考需要哪些狀態？

結尾元素位置i。

- 定義dp數組含義。

```
dp[i]: the length of the longest strictly increasing subsequence ending at nums[i].
```

- 推出狀態轉移方程。

```
if (nums[i]>nums[j]) dp[i]=max(dp[i], dp[j]+1);
```

- 設定邊界條件及dp初始值。

以任意元素結尾最長遞增子序列長度最少為1，因此dp初始值給1。

```
vector<int>dp(n, 1);
```

- 得出結論。

最長遞增子序列可能以任意元素結尾，搜一遍dp數組可知最長遞增子序列長度。

```
max{ dp[i] } for i=0,1,.. ,n-1
```

### 二分法

逐個讀取元素，當元素大於升序序列最後一個元素時，直接將該元素加入序列。若小於等於升序序列最後一個元素，則二分搜索升序序列中第一個大於等於該元素的位置，並將該位置改為該元素。這樣做的好處是保持序列升序及長度不變的同時讓序列數字變小，更有利於未來插入數字。

```
1 2 3 5 9 5 6 7

1 2 3 5 9 <- 5 => 1 2 3 5 9
1 2 3 5 9 <- 6 => 1 2 3 5 6
1 2 3 5 6 <- 7 => 1 2 3 5 6 7
```
