# 1723.Find-Minimum-Time-to-Finish-All-Jobs

### 狀態壓縮dp

發現工作數最多12個，可以用12個bit表示工作完成的狀態。

- 對於第i個工人可以做哪些選擇？

```
X X X X X [X] i
```

第i個工人完成工作花費時數跟前i-1個工人完成剩餘工作花費最小時數中取大就有機會更新前i個工人完成所有工作花費的最少時間。

- 思考需要哪些狀態？

當前工人位置訊息i、所有工作完成的狀態p。

- 定義dp數組含義。

```
dp[i][p]: the minimum possible maximum working time of i-th worker with pattern p.
```

- 推導狀態轉移方程。

遍歷一遍工作完成狀態的所有非空子集就是工人在該工作完成狀態底下所有可能完成工作的組合。

```
dp[i][p]=min(dp[i][p], max(dp[i-1][p-subset], times[subset]));
```

- 設定邊界條件及dp初始值。

沒有任何工作完成所需花費的最小時數為0當作邊界條件。要求最小值dp數組初始值給最大值。

```
dp[0]=0;
```

- 得出結論。

完成所有n份工作最小花費時數為dp[(1<<n)-1]。

### 二分搜值+dfs

隨便猜一個最大工作時數，以該時數試著分配工作給每位工人，若所有工作能夠在不超過最大工作時數的情況下分配完成，就再收縮右邊界嘗試更小的最大工作時數。反之代表最大工作時數太小，需要收縮左邊界。利用二分思路搜尋左側邊界。
