# 2522.Partition-String-Into-Substrings-With-Values-at-Most-K

處理最後一個數字需要遍歷所有可能分割點j，很容易想到N^2的解法。

### N^2常規暴力解

- 思考對於第i個元素可以做哪些選擇？

```
X X X [j X X X i]
```

s[j:i]表示的數字小於等於目標值時，可以做一次分割，前面j-1個元素的最小分割個數再加上這個數字有機會更新前i個元素的最小分割個數。

- 思考需要哪些狀態？

元素位置i。

- 定義dp數組含義。

```
dp[i]: the minimum number of substrings in a good partition of s[1:i].
```

- 推出狀態轉移方程。

```
if (stol(s.substr(j, i-j+1))<=k) dp[i]=min(dp[i], dp[j-1]+1);
```

- 設定邊界條件及dp初始值。

0個元素最少有0個分割數，要求最小值dp數組初始值給最大值。

```
dp[0]=0;
```

- 得出結論。

前n個元素的最小分割數為dp[n]。

遍歷完所有元素跟分割份數後，數據量達到1e5，再遍歷最後一個數字的所有分割點j可能會TLE。因此時間複雜度需要壓在N。

### N優化解

優化思路通常要從消除遍歷分割點j的循環下手，運用題目給出的性質在遍歷每個元素i的循環中用常數時間得出分割點j。

- 已知最後一段[j:i]的偏移量offset。

知道偏移量可以運用數組的優勢直接算出分割點j，這題屬於這種情況，有給目標值代表可從目標值推算出最後一個子串的最大長度。

```
i-offset => j
```

- 已知i與j滿足某種數學表達式。

將數學計算結果跟索引的映射用哈希表存起來，後續遍歷到元素i時可通過查表得出分割點j，經典題型涵蓋 #3202 跟大多數前綴和題目。

```
Map[cal(i)] => j
```

- 已知j是滑動窗口中的最值。

經典題型涵蓋所有雙端隊列的題目。

```
dq.front() => j
```
