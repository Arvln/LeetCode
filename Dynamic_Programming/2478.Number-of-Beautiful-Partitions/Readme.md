# 2478.Number-of-Beautiful-Partitions

很容易可以想到N^3的解法，遍歷最後一份的所有分割點就行。

- 對於最後一份可以做哪些選擇？

```
[X X X X X X X] [j X X X i]
```

找出符合條件的最後一個子數組，將前面所有符合條件的子數組數累加上去就行。

- 思考需要哪些狀態？

標示當前元素位置i跟分割份數k。

- 定義dp數組含義。

```
dp[i][k]: the number of beautiful partitions of s[1:i] split into k subarrays.
```

- 推導狀態轉移方程。

```
dp[i][k]+=dp[j-1][k-1] for j=k,k+1,..,i-minLength+1
```

- 設定邊界條件及dp數組初始值。

0個元素分成0份算作一種方法作為初始條件，要求和初始值給0方便計算。

```
dp[0][0]=1;
```

- 得出結論

所有n個元素分成K份的方法數為dp[n][K]。

- 優化

依據數據量推斷算法最多只能接受N^2的時間複雜度，需要思考如何進行優化。遍歷分割點的循環是為計算質數分割點前有效數組數量，可以利用遍歷所有元素的循環搭配minLength計算出分割點j，若該分割點是質數分割點，則可以累加分割點前有效數組數量並去掉遍歷所有分割點的循環。
